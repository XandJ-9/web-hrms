# 后端开发规范

- 技术栈：Django 5.x + Django REST framework（DRF） + Simple JWT
- 项目位置：`backend/`
- 已开发模块：`system`（用户、菜单、字典、认证相关）
- 统一风格：前端为 RuoYi 风格，接口返回采用包裹结构（`code`、`msg`、`data`/`rows`/`total`），异常统一包装

## 目录结构

- 总体结构
  - `backend/config/`：项目配置（`settings.py`、`urls.py`、`wsgi.py`、`asgi.py`）
  - `backend/system/`：业务应用（模型、序列化、视图、路由、异常、命令、迁移）
- `system` 模块示例
  - `models.py`：实体模型（用户、部门、角色、菜单、字典）
  - `serializers.py`：序列化定义（字段映射为驼峰）
  - `views/`：`core.py`（认证、基础信息、路由生成）、`user.py`（用户与扩展动作）、`menu.py`（菜单）、`dict.py`（字典类型与数据）
  - `urls.py`：DRF `DefaultRouter` + 认证路由
  - `exceptions.py`：DRF 异常统一处理
  - `management/commands/init_menus.py`：初始化菜单命令
  - `migrations/`：数据迁移

### 示例代码片段（替换行号引用）

```python
# models.py（类名）
class Dept(models.Model): ...
class User(AbstractUser): ...
class Role(models.Model): ...
class Menu(models.Model): ...
class DictType(models.Model): ...
class DictData(models.Model): ...
```

```python
# serializers.py（类名与关键字段映射）
class UserSerializer(serializers.ModelSerializer):
    def get_dept(self, obj): ...
    class Meta:
        model = User
        fields = ["id", "username", "nick_name", ...]

class MenuSerializer(serializers.ModelSerializer):
    menuId = serializers.IntegerField(source='menu_id', read_only=True)
    parentId = serializers.IntegerField(source='parent_id')
    menuName = serializers.CharField(source='menu_name')
    class Meta:
        model = Menu
        fields = ["menuId", "parentId", "menuName", ...]

class DictTypeSerializer(serializers.ModelSerializer):
    dictId = serializers.IntegerField(source='dict_id', read_only=True)
    class Meta:
        model = DictType
        fields = ["dictId", "dictName", "dictType", ...]

class DictDataSerializer(serializers.ModelSerializer):
    dictCode = serializers.IntegerField(source='dict_code', read_only=True)
    class Meta:
        model = DictData
        fields = ["dictCode", "dictSort", "dictLabel", ...]
```

```python
# views/core.py（类与方法）
class CaptchaView(TokenObtainPairView):
    def get(self, request, *args, **kwargs): ...

class LoginView(TokenObtainPairView):
    def post(self, request, *args, **kwargs): ...  # 返回 {"token": access}

class GetInfoView(APIView):
    def get(self, request): ...  # 返回用户、角色、权限

class LogoutView(APIView):
    def post(self, request): ...

class GetRoutersView(APIView):
    def get(self, request): ...  # 菜单转前端路由结构
```

```python
# views/user.py（类与方法）
class UserViewSet(viewsets.ModelViewSet):
    def get_queryset(self): ...
    @action(detail=False, methods=['get'])
    def deptTree(self, request): ...
```

```python
# views/menu.py（类与方法）
class MenuViewSet(viewsets.ModelViewSet):
    def list(self, request, *args, **kwargs): ...
    def retrieve(self, request, *args, **kwargs): ...
    def create(self, request, *args, **kwargs): ...
```

```python
# views/dict.py（类与方法）
class DictTypeViewSet(viewsets.ModelViewSet):
    def list(self, request, *args, **kwargs): ...
    @action(detail=False, methods=['get'], url_path='optionselect')
    def optionselect(self, request): ...

class DictDataViewSet(viewsets.ModelViewSet):
    def list(self, request, *args, **kwargs): ...
    @action(detail=False, methods=['get'], url_path=r'type/(?P<dict_type>[^/]+)')
    def by_type(self, request, dict_type=None): ...
```

```python
# urls.py（路由注册）
router = DefaultRouter()
router.trailing_slash = '/?'
router.register(r'user', UserViewSet, basename='user')
router.register(r'menu', MenuViewSet, basename='menu')
router.register(r'dict/type', DictTypeViewSet, basename='dict-type')
router.register(r'dict/data', DictDataViewSet, basename='dict-data')

urlpatterns = [
    path('system/', include(router.urls)),
    path('login', LoginView.as_view()),
    path('captchaImage/', CaptchaView.as_view()),
    path('getInfo', GetInfoView.as_view()),
    path('logout', LogoutView.as_view()),
    path('getRouters', GetRoutersView.as_view()),
]
```

```python
# exceptions.py（统一异常处理）
def custom_exception_handler(exc, context):
    response = exception_handler(exc, context)
    if response is not None:
        return Response({'code': response.status_code, 'message': _first_error_message(response.data) or '请求错误'}, status=status.HTTP_200_OK)
    return Response({'code': 500, 'message': '服务器内部错误'}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
```

```python
# management/commands/init_menus.py（命令入口）
class Command(BaseCommand):
    def handle(self, *args, **options): ...
```

## 模块结构规范

- 每个业务模块（Django app）应包含：
  - `models.py`：模型定义，字段完整、含 `Meta`（`db_table`、`verbose_name`）
  - `serializers.py`：输出为驼峰命名；输入校验与业务约束分离
  - `views/*.py`：按资源拆分视图，使用 `ModelViewSet`；分页、筛选、排序、软删除
  - `urls.py`：使用 `DefaultRouter`，设定 `router.trailing_slash='/?'` 保持路径兼容
  - `exceptions.py`（或全局异常模块）：统一异常处理入口在 `settings.py` 配置
  - 可选：`management/commands/*.py`（初始化数据、批处理）、`permissions.py`（细粒度权限）

## REST 与返回规范

- 统一响应格式（成功）
  - 列表：
    ```python
    def list(self, request, *args, **kwargs):
        qs = self.get_queryset()
        page = self.paginate_queryset(qs)
        if page is not None:
            serializer = self.get_serializer(page, many=True)
            return self.get_paginated_response(serializer.data)
        serializer = self.get_serializer(qs, many=True)
        return Response({'code': 200, 'msg': '操作成功', 'rows': serializer.data, 'total': len(serializer.data)})
    ```
  - 详情：
    ```python
    def retrieve(self, request, *args, **kwargs):
        instance = self.get_object()
        data = self.get_serializer(instance).data
        return Response({'code': 200, 'msg': '操作成功', 'data': data})
    ```
  - 新增/修改/删除：
    ```python
    def create(self, request, *args, **kwargs):
        serializer = self.get_serializer(data=request.data)
        serializer.is_valid(raise_exception=True)
        serializer.save()
        return Response({'code': 200, 'msg': '操作成功'})
    ```
  - 路由：
    ```python
    class GetRoutersView(APIView):
        def get(self, request):
            routers = ...  # 菜单转前端路由
            return Response({'code': 200, 'msg': '操作成功', 'data': routers})
    ```
- 统一错误包装
  - 全局异常处理：在 `config.settings` 的 `REST_FRAMEWORK` 中设置 `EXCEPTION_HANDLER = 'system.exceptions.custom_exception_handler'`
  - 行为：
    - DRF 处理的异常 → HTTP 200，包裹为 `{"code": <status_int>, "message": <first_error>}`
    - 未处理异常 → HTTP 500，`{"code": 500, "message": "服务器内部错误"}`
- 分页与查询
  - 分页参数：`pageNum`（默认 1）、`pageSize`（默认 10）
  - 返回：`total` + `rows`
- 路径与方法约定
  - 列表：`GET /system/<resource>` 或兼容 `GET /system/<resource>/list`
  - 详情：`GET /system/<resource>/{id}`
  - 新增：`POST /system/<resource>`
  - 修改：`PUT /system/<resource>`
  - 删除：`DELETE /system/<resource>/{id}`
  - 扩展动作：`@action(detail=False/True, methods=['get'|'put'|'delete'...])`

## 序列化与参数规范

- 输出序列化（字段映射为驼峰）
  - 菜单：`MenuSerializer` 字段映射示例
    - 映射：`menu_id → menuId`、`parent_id → parentId`、`menu_name → menuName`、`order_num → orderNum`、`is_frame → isFrame` 等
  - 字典类型：`DictTypeSerializer`
  - 字典数据：`DictDataSerializer`
  - 用户：`UserSerializer` 包含衍生 `dept` 字段（`deptId`、`deptName`）
- 输入序列化（建议）
  - 创建/更新序列化：针对每个资源定义 `CreateSerializer` / `UpdateSerializer`（或合并 `UpsertSerializer`），校验必填字段、枚举约束、长度限制等
  - 查询参数序列化：定义 `QuerySerializer`（包含业务筛选 + `PaginationSerializer`）
  - 枚举约束（示例）：
    - `menuType ∈ {M, C, F}`、`visible ∈ {0, 1}`、`status ∈ {0, 1}`、`isFrame ∈ {0, 1}`、`isCache ∈ {0, 1}`

### 序列化与参数处理优化

-  实现字段自动映射工具（如下划线与驼峰互转），替代序列化器中手动配置source的方式；
-  为列表接口定义专用查询参数序列化器（如UserQuerySerializer），集中处理筛选条件、分页参数的校验逻辑；
-  拆分创建 / 更新序列化器（CreateSerializer/UpdateSerializer），明确输入校验规则（必填、枚举、长度等）。



## 认证与权限

- 认证方式
  - JWT：`DEFAULT_AUTHENTICATION_CLASSES = ('rest_framework_simplejwt.authentication.JWTAuthentication',)`（`config.settings`）
- 鉴权
  - 需登录接口：`permission_classes = [IsAuthenticated]`（示例：`GetInfoView`、`DictTypeViewSet`、`DictDataViewSet`）
- 登录与验证码
  - 验证码：`GET /captchaImage/` 返回 `img`（Base64）、`uuid`、`captchaEnabled`
  - 登录：`POST /login` 返回 `{"token": <jwt_access>}`
  - 登出：`POST /logout` 返回统一成功包

## 异常处理

- 统一异常入口：`system.exceptions.custom_exception_handler`（在 `config.settings.REST_FRAMEWORK` 中配置）
- 错误信息提取：优先 `detail`，否则提取首个字段错误
- 返回行为：
  - DRF 异常 → HTTP 200 + `{"code": <http_status>, "message": <msg>}`
  - 未捕获异常 → HTTP 500 + `{"code": 500, "message": "服务器内部错误"}`

## 实现约定与建议

- 软删除约定
  - 有 `del_flag` 的资源均采用软删除（置 `del_flag='1'`），查询统一过滤 `del_flag='0'`（参考：`Menu`、`DictType`、`DictData`）
- 驼峰输出
  - 所有对前端的输出按驼峰命名，使用 `source` 进行字段映射（参考 `MenuSerializer`）
- 列表别名
  - 兼容前端 `/list` 风格：在视图集添加 `@action(detail=False, methods=['get'], url_path='list')`（如 `DictTypeViewSet.list_action`、`DictDataViewSet.list_action`）并复用 `list()`
- 权限与鉴权
  - 默认所有系统接口需登录；登录、验证码接口除外
- 统一日志
  - 在 `list/create/update/destroy` 等关键操作处记录审计字段（`create_by/update_by`），从 `request.user` 注入

## 参考代码位置（文件与类/函数名）

- 全局配置与异常：`config.settings.REST_FRAMEWORK`、`system.exceptions.custom_exception_handler`
- 路由注册：`system.urls`（`DefaultRouter`、`urlpatterns`）
- 用户：`system.views.user.UserViewSet.get_queryset`、`deptTree`
- 菜单：`system.views.menu.MenuViewSet.list`、`retrieve`、`create`
- 字典：`system.views.dict.DictTypeViewSet.list`、`optionselect`；`system.views.dict.DictDataViewSet.list`、`by_type`
- 认证与路由：`system.views.core.LoginView.post`、`GetInfoView.get`、`LogoutView.post`、`GetRoutersView.get`
- 序列化：`system.serializers.UserSerializer`、`MenuSerializer`、`DictTypeSerializer`、`DictDataSerializer`
- 分页类：`system.pagination.StandardPagination`（全局配置）
- 视图基类：`system.views.core.BaseViewSet`（统一软删除、审计字段）
- 权限：`system.permission.HasRolePermission`
- 审计日志：`system.common.audit_log`
- 字段转换工具：`system.common.camel_to_snake`、`system.common.snake_to_camel`、`system.common.normalize_input`


## 优化建议

### 架构与复用性优化（已落实）

-  抽象BaseModel基类，封装公共字段（create_time、update_time、create_by、update_by、del_flag），已有模型继承：`Dept/User/Role/Menu/DictType/DictData`

-  定义BaseViewSet基类，统一软删除过滤、`create_by/update_by` 自动注入、入参驼峰转下划线，业务视图集已继承：`UserViewSet/MenuViewSet/DictTypeViewSet/DictDataViewSet`

-  使用 DRF 分页类标准化分页处理，替代手工 `start/end`。全局配置 `DEFAULT_PAGINATION_CLASS = 'system.pagination.StandardPagination'`，统一参数 `pageNum/pageSize` 与返回结构 `total+rows`

### 文档与接口（已落实）

-  集成 `drf-spectacular`，提供接口文档：`/api/schema` 与 `/api/docs`

### 权限与安全（已落实）

-  RBAC 权限控制：`HasRolePermission`，支持 `required_roles`
-  审计日志：`audit_log` 装饰器用于登录、登出、修改类接口，已使用 `functools.wraps` 保证路由注册正确

### 性能与缓存（已落实）

-  高频字段索引：为 `del_flag/parent_id/status/dict_type` 等添加索引
-  菜单路由与字典数据按类型接口增加缓存，默认 1 小时

## 变更记录（2025-11-17）

- 新增 `system.pagination.StandardPagination` 并在 `settings.REST_FRAMEWORK.DEFAULT_PAGINATION_CLASS` 启用
- 新增 `BaseModel` 并让核心模型继承，去除重复审计字段
- 新增 `BaseViewSet` 并在用户、菜单、字典视图集中启用
- 修复审计装饰器路由注册问题：`audit_log` 使用 `functools.wraps`
- 集成 `drf-spectacular` 并在 `config.urls` 暴露 `/api/schema` 与 `/api/docs`



### 权限与安全强化

-  基于Role模型扩展 DRF 权限类，实现 RBAC 细粒度权限控制（如HasRolePermission），在视图中通过required_roles指定允许访问的角色；

-  对登录、权限变更、数据删除等敏感操作，通过中间件或装饰器记录审计日志，包含操作用户、操作路径、方法等信息。

### 性能与可维护性提升

-  优化数据库查询：关联查询使用select_related/prefetch_related减少 SQL 请求；为高频过滤字段（del_flag、parent_id等）添加数据库索引；

-  对字典、菜单等静态数据添加缓存（如 Django 缓存框架），设置合理过期时间（如 1 小时）以减少数据库压力；

-  按业务逻辑拆分视图文件，保持views/目录清晰，避免单个文件代码冗余。

### 测试与文档完善

-  为核心模型、序列化器、视图编写单元测试，验证字段映射、权限控制、业务逻辑正确性；

-  集成drf-spectacular生成 OpenAPI 文档，自动同步接口信息，方便前后端协作。
